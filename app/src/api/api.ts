/* tslint:disable */
/* eslint-disable */
/**
 * PulsBackend
 * API Puls
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BadRequest
 */
export interface BadRequest {
    /**
     * Код ошибки
     * @type {string}
     * @memberof BadRequest
     */
    'error': string;
    /**
     * Сообщение для пользователя
     * @type {string}
     * @memberof BadRequest
     */
    'user_message': string;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface ContentTitles
 */
export interface ContentTitles {
    /**
     * Заголовок для кейса или истории успеха
     * @type {string}
     * @memberof ContentTitles
     */
    'title1': string;
    /**
     * Заголовок для прогнозов или трендов
     * @type {string}
     * @memberof ContentTitles
     */
    'title2': string;
    /**
     * Заголовок для советов или лайфхаков
     * @type {string}
     * @memberof ContentTitles
     */
    'title3': string;
    /**
     * Заголовок для мотивационного контента
     * @type {string}
     * @memberof ContentTitles
     */
    'title4': string;
    /**
     * Заголовок для презентации уникальных методов
     * @type {string}
     * @memberof ContentTitles
     */
    'title5': string;
    /**
     * Заголовок для разоблачений или экспертных мнений
     * @type {string}
     * @memberof ContentTitles
     */
    'title6': string;
    /**
     * id недели
     * @type {number}
     * @memberof ContentTitles
     */
    'week_id'?: number;
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * 
     * @type {number}
     * @memberof CreatePaymentRequest
     */
    'tariff_id': number;
}
/**
 * 
 * @export
 * @interface CreatePostImageRequest
 */
export interface CreatePostImageRequest {
    /**
     * Описание изображения
     * @type {string}
     * @memberof CreatePostImageRequest
     */
    'post': string;
    /**
     * Размер изображения
     * @type {string}
     * @memberof CreatePostImageRequest
     */
    'size': string;
}
/**
 * 
 * @export
 * @interface CreatePostRequest
 */
export interface CreatePostRequest {
    /**
     * Дополнительные примечания
     * @type {string}
     * @memberof CreatePostRequest
     */
    'additions'?: string;
    /**
     * длина поста
     * @type {number}
     * @memberof CreatePostRequest
     */
    'length': number;
    /**
     * Тема поста
     * @type {string}
     * @memberof CreatePostRequest
     */
    'post_topic': string;
    /**
     * Тип поста
     * @type {string}
     * @memberof CreatePostRequest
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CreatePromptImageRequest
 */
export interface CreatePromptImageRequest {
    /**
     * Описание изображения
     * @type {string}
     * @memberof CreatePromptImageRequest
     */
    'prompt': string;
    /**
     * Размер изображения
     * @type {string}
     * @memberof CreatePromptImageRequest
     */
    'size': string;
}
/**
 * 
 * @export
 * @interface GetAuthGetUserId200Response
 */
export interface GetAuthGetUserId200Response {
    /**
     * Идентификатор пользователя
     * @type {number}
     * @memberof GetAuthGetUserId200Response
     */
    'user_id'?: number;
}
/**
 * 
 * @export
 * @interface GetPostByIdRequest
 */
export interface GetPostByIdRequest {
    /**
     * id поста
     * @type {number}
     * @memberof GetPostByIdRequest
     */
    'post_id'?: number;
}
/**
 * 
 * @export
 * @interface GetProfileFromAnswersRequest
 */
export interface GetProfileFromAnswersRequest {
    /**
     * Примеры постов
     * @type {Array<string>}
     * @memberof GetProfileFromAnswersRequest
     */
    'post_sample'?: Array<string>;
    /**
     * Ответ на вопрос 1
     * @type {string}
     * @memberof GetProfileFromAnswersRequest
     */
    'q1': string;
    /**
     * Ответ на вопрос 2
     * @type {string}
     * @memberof GetProfileFromAnswersRequest
     */
    'q2': string;
    /**
     * Ответ на вопрос 3
     * @type {string}
     * @memberof GetProfileFromAnswersRequest
     */
    'q3': string;
    /**
     * Ответ на вопрос 4
     * @type {string}
     * @memberof GetProfileFromAnswersRequest
     */
    'q4': string;
    /**
     * Ответ на вопрос 5
     * @type {string}
     * @memberof GetProfileFromAnswersRequest
     */
    'q5': string;
    /**
     * Ответ на вопрос 6
     * @type {string}
     * @memberof GetProfileFromAnswersRequest
     */
    'q6': string;
    /**
     * флаг того что пользователь для генерации бцдет использовать примеры своих постов
     * @type {boolean}
     * @memberof GetProfileFromAnswersRequest
     */
    'use_post_sample'?: boolean;
}
/**
 * 
 * @export
 * @interface GetProfileFromUrlRequest
 */
export interface GetProfileFromUrlRequest {
    /**
     * Ссылка на профиль
     * @type {string}
     * @memberof GetProfileFromUrlRequest
     */
    'link': string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MarkPostReadyToPublish
 */
export interface MarkPostReadyToPublish {
    /**
     * id поста
     * @type {number}
     * @memberof MarkPostReadyToPublish
     */
    'post_id'?: number;
}
/**
 * 
 * @export
 * @interface PaymentResponse
 */
export interface PaymentResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentResponse
     */
    'confirmation_url'?: string;
}
/**
 * 
 * @export
 * @interface PostAuthChangePassword500Response
 */
export interface PostAuthChangePassword500Response {
    /**
     * Описание ошибки
     * @type {string}
     * @memberof PostAuthChangePassword500Response
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PostAuthLogin200Response
 */
export interface PostAuthLogin200Response {
    /**
     * JWT токен для аутентификации
     * @type {string}
     * @memberof PostAuthLogin200Response
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface PostContentCreateImagePost200Response
 */
export interface PostContentCreateImagePost200Response {
    /**
     * URL сгенерированного изображения
     * @type {string}
     * @memberof PostContentCreateImagePost200Response
     */
    'image_url'?: string;
}
/**
 * 
 * @export
 * @interface PostContentCreatePost200Response
 */
export interface PostContentCreatePost200Response {
    /**
     * Текст сгенерированного поста
     * @type {string}
     * @memberof PostContentCreatePost200Response
     */
    'post_text'?: string;
}
/**
 * 
 * @export
 * @interface PostContentSavePost200Response
 */
export interface PostContentSavePost200Response {
    /**
     * id сохраненного поста
     * @type {number}
     * @memberof PostContentSavePost200Response
     */
    'post_id'?: number;
}
/**
 * 
 * @export
 * @interface PostContentTranscribe200Response
 */
export interface PostContentTranscribe200Response {
    /**
     * текст полученный из аудио
     * @type {string}
     * @memberof PostContentTranscribe200Response
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface PostPaymentUsePromo200Response
 */
export interface PostPaymentUsePromo200Response {
    /**
     * Размер скидки в процентах
     * @type {number}
     * @memberof PostPaymentUsePromo200Response
     */
    'discount'?: number;
}
/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    'password': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterRequest
     */
    'verification_code': number;
}
/**
 * 
 * @export
 * @interface SaveAccountRequest
 */
export interface SaveAccountRequest {
    /**
     * URL телеграм-канала
     * @type {string}
     * @memberof SaveAccountRequest
     */
    'tg_channel_url'?: string;
    /**
     * URL VK-канала
     * @type {string}
     * @memberof SaveAccountRequest
     */
    'vk_channel_url'?: string;
    /**
     * Токен для доступа к API VK
     * @type {string}
     * @memberof SaveAccountRequest
     */
    'vk_token'?: string;
}
/**
 * 
 * @export
 * @interface SavePostRequest
 */
export interface SavePostRequest {
    /**
     * массив ссылок на изображения
     * @type {Array<string>}
     * @memberof SavePostRequest
     */
    'image_urls'?: Array<string>;
    /**
     * флаг того что пост создан в рамках контент плана или нет
     * @type {boolean}
     * @memberof SavePostRequest
     */
    'in_content_plan'?: boolean;
    /**
     * название поста
     * @type {string}
     * @memberof SavePostRequest
     */
    'post_topic'?: string;
    /**
     * текст поста
     * @type {string}
     * @memberof SavePostRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface SendEmailCodeRequest
 */
export interface SendEmailCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof SendEmailCodeRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface SendLinkRequest
 */
export interface SendLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof SendLinkRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface UpdatePostRequest
 */
export interface UpdatePostRequest {
    /**
     * массив ссылок на изображения
     * @type {Array<string>}
     * @memberof UpdatePostRequest
     */
    'image_urls'?: Array<string>;
    /**
     * id поста
     * @type {number}
     * @memberof UpdatePostRequest
     */
    'post_id'?: number;
    /**
     * название поста
     * @type {string}
     * @memberof UpdatePostRequest
     */
    'post_topic'?: string;
    /**
     * текст поста
     * @type {string}
     * @memberof UpdatePostRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface UsePromoRequest
 */
export interface UsePromoRequest {
    /**
     * 
     * @type {string}
     * @memberof UsePromoRequest
     */
    'promocode': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает user_id пользователя. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение user_id по токенам
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthGetUserId: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/get_user_id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает токен и новый пароль, проверяет токен и изменяет пароль пользователя. Если токен невалиден или пароль не соответствует требованиям, возвращается ошибка `400 Bad Request`. 
         * @summary Изменение пароля пользователя
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthChangePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('postAuthChangePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/auth/change_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает email и пароль пользователя, проверяет их и возвращает токен для аутентификации. Если email или пароль неверны, возвращается ошибка `400 Bad Request`. 
         * @summary Вход в систему
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogin: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('postAuthLogin', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает данные для регистрации, проверяет код подтверждения и возвращает токен. Если данные невалидны или код подтверждения неверен, возвращается ошибка `400 Bad Request`. 
         * @summary Регистрация нового пользователя
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthRegister: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('postAuthRegister', 'registerRequest', registerRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает email адрес и отправляет на него ссылку для восстановления пароля. Если email невалиден или пользователь с таким email не найден, возвращается ошибка `400 Bad Request`. 
         * @summary Отправка ссылки для восстановления пароля
         * @param {SendLinkRequest} sendLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthSendLink: async (sendLinkRequest: SendLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendLinkRequest' is not null or undefined
            assertParamExists('postAuthSendLink', 'sendLinkRequest', sendLinkRequest)
            const localVarPath = `/auth/send_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает email адрес, валидирует его и отправляет код подтверждения. Если email невалиден, возвращается ошибка `400 Bad Request`. 
         * @summary Отправить код подтверждения на email
         * @param {SendEmailCodeRequest} sendEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSendEmailCode: async (sendEmailCodeRequest: SendEmailCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendEmailCodeRequest' is not null or undefined
            assertParamExists('postSendEmailCode', 'sendEmailCodeRequest', sendEmailCodeRequest)
            const localVarPath = `/send_email_code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendEmailCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает user_id пользователя. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение user_id по токенам
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthGetUserId(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAuthGetUserId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthGetUserId(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getAuthGetUserId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает токен и новый пароль, проверяет токен и изменяет пароль пользователя. Если токен невалиден или пароль не соответствует требованиям, возвращается ошибка `400 Bad Request`. 
         * @summary Изменение пароля пользователя
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthChangePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthChangePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postAuthChangePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает email и пароль пользователя, проверяет их и возвращает токен для аутентификации. Если email или пароль неверны, возвращается ошибка `400 Bad Request`. 
         * @summary Вход в систему
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAuthLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthLogin(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postAuthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает данные для регистрации, проверяет код подтверждения и возвращает токен. Если данные невалидны или код подтверждения неверен, возвращается ошибка `400 Bad Request`. 
         * @summary Регистрация нового пользователя
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthRegister(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAuthLogin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthRegister(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postAuthRegister']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает email адрес и отправляет на него ссылку для восстановления пароля. Если email невалиден или пользователь с таким email не найден, возвращается ошибка `400 Bad Request`. 
         * @summary Отправка ссылки для восстановления пароля
         * @param {SendLinkRequest} sendLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthSendLink(sendLinkRequest: SendLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthSendLink(sendLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postAuthSendLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает email адрес, валидирует его и отправляет код подтверждения. Если email невалиден, возвращается ошибка `400 Bad Request`. 
         * @summary Отправить код подтверждения на email
         * @param {SendEmailCodeRequest} sendEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSendEmailCode(sendEmailCodeRequest: SendEmailCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSendEmailCode(sendEmailCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postSendEmailCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает user_id пользователя. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение user_id по токенам
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthGetUserId(options?: RawAxiosRequestConfig): AxiosPromise<GetAuthGetUserId200Response> {
            return localVarFp.getAuthGetUserId(options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает токен и новый пароль, проверяет токен и изменяет пароль пользователя. Если токен невалиден или пароль не соответствует требованиям, возвращается ошибка `400 Bad Request`. 
         * @summary Изменение пароля пользователя
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthChangePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postAuthChangePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает email и пароль пользователя, проверяет их и возвращает токен для аутентификации. Если email или пароль неверны, возвращается ошибка `400 Bad Request`. 
         * @summary Вход в систему
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostAuthLogin200Response> {
            return localVarFp.postAuthLogin(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает данные для регистрации, проверяет код подтверждения и возвращает токен. Если данные невалидны или код подтверждения неверен, возвращается ошибка `400 Bad Request`. 
         * @summary Регистрация нового пользователя
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthRegister(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostAuthLogin200Response> {
            return localVarFp.postAuthRegister(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает email адрес и отправляет на него ссылку для восстановления пароля. Если email невалиден или пользователь с таким email не найден, возвращается ошибка `400 Bad Request`. 
         * @summary Отправка ссылки для восстановления пароля
         * @param {SendLinkRequest} sendLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthSendLink(sendLinkRequest: SendLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postAuthSendLink(sendLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает email адрес, валидирует его и отправляет код подтверждения. Если email невалиден, возвращается ошибка `400 Bad Request`. 
         * @summary Отправить код подтверждения на email
         * @param {SendEmailCodeRequest} sendEmailCodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSendEmailCode(sendEmailCodeRequest: SendEmailCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postSendEmailCode(sendEmailCodeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает user_id пользователя. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получение user_id по токенам
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthGetUserId(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthGetUserId(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает токен и новый пароль, проверяет токен и изменяет пароль пользователя. Если токен невалиден или пароль не соответствует требованиям, возвращается ошибка `400 Bad Request`. 
     * @summary Изменение пароля пользователя
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthChangePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuthChangePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает email и пароль пользователя, проверяет их и возвращает токен для аутентификации. Если email или пароль неверны, возвращается ошибка `400 Bad Request`. 
     * @summary Вход в систему
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthLogin(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuthLogin(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает данные для регистрации, проверяет код подтверждения и возвращает токен. Если данные невалидны или код подтверждения неверен, возвращается ошибка `400 Bad Request`. 
     * @summary Регистрация нового пользователя
     * @param {RegisterRequest} registerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthRegister(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuthRegister(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает email адрес и отправляет на него ссылку для восстановления пароля. Если email невалиден или пользователь с таким email не найден, возвращается ошибка `400 Bad Request`. 
     * @summary Отправка ссылки для восстановления пароля
     * @param {SendLinkRequest} sendLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthSendLink(sendLinkRequest: SendLinkRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuthSendLink(sendLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает email адрес, валидирует его и отправляет код подтверждения. Если email невалиден, возвращается ошибка `400 Bad Request`. 
     * @summary Отправить код подтверждения на email
     * @param {SendEmailCodeRequest} sendEmailCodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postSendEmailCode(sendEmailCodeRequest: SendEmailCodeRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postSendEmailCode(sendEmailCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Роут принимает id юзера и возвращает его контент планы. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGetContentPlans: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/get_content_plans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает `user_id` и `week_id` в query-параметрах и возвращает контент-планы пользователя для указанной недели. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {number} weekId ID недели
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGetDetailContentPlan: async (weekId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'weekId' is not null or undefined
            assertParamExists('getContentGetDetailContentPlan', 'weekId', weekId)
            const localVarPath = `/content/get_detail_content_plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (weekId !== undefined) {
                localVarQueryParameter['week_id'] = weekId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает id юзера и возвращает его посты. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGetPostsNotInContentPlan: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/get_posts_not_in_content_plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает id, текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary обновление
         * @param {UpdatePostRequest} updatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchContentUpdatePost: async (updatePostRequest: UpdatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePostRequest' is not null or undefined
            assertParamExists('patchContentUpdatePost', 'updatePostRequest', updatePostRequest)
            const localVarPath = `/content/update_post/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает ответы на вопросы и историю постов. На основе этих данных генерируется контент план. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание контент плана
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreateContentPlan: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content/create_content_plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает название поста и размер желаемого изображения. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание изображения на основе описания
         * @param {CreatePostImageRequest} createPostImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreateImagePost: async (createPostImageRequest: CreatePostImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPostImageRequest' is not null or undefined
            assertParamExists('postContentCreateImagePost', 'createPostImageRequest', createPostImageRequest)
            const localVarPath = `/content/create_image_post/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPostImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает описание изображения (prompt) и его размер. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание изображения на основе описания
         * @param {CreatePromptImageRequest} createPromptImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreateImagePrompt: async (createPromptImageRequest: CreatePromptImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPromptImageRequest' is not null or undefined
            assertParamExists('postContentCreateImagePrompt', 'createPromptImageRequest', createPromptImageRequest)
            const localVarPath = `/content/create_image_prompt/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPromptImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает ответы на вопросы, параметры длины, тему поста, дополнительные примечания и тип поста. На основе этих данных генерируется текст поста. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание поста на основе ответов
         * @param {CreatePostRequest} createPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreatePost: async (createPostRequest: CreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPostRequest' is not null or undefined
            assertParamExists('postContentCreatePost', 'createPostRequest', createPostRequest)
            const localVarPath = `/content/create_post/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает id поста и возвращает информацию о нем Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение информации о посте по id
         * @param {GetPostByIdRequest} getPostByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentGetPostById: async (getPostByIdRequest: GetPostByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getPostByIdRequest' is not null or undefined
            assertParamExists('postContentGetPostById', 'getPostByIdRequest', getPostByIdRequest)
            const localVarPath = `/content/get_post_by_id/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPostByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает id поста и помечает его готовым  Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Пометить пост готовым к публикации
         * @param {MarkPostReadyToPublish} markPostReadyToPublish 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentMarkReadyToPublish: async (markPostReadyToPublish: MarkPostReadyToPublish, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'markPostReadyToPublish' is not null or undefined
            assertParamExists('postContentMarkReadyToPublish', 'markPostReadyToPublish', markPostReadyToPublish)
            const localVarPath = `/content/mark_ready_to_publish/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markPostReadyToPublish, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Сохранение поста
         * @param {SavePostRequest} savePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentSavePost: async (savePostRequest: SavePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'savePostRequest' is not null or undefined
            assertParamExists('postContentSavePost', 'savePostRequest', savePostRequest)
            const localVarPath = `/content/save_post/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает аудиофайл и возвращает текст из него. Если данные невалидны, возвращается ошибка `400 Bad Request` 
         * @summary транскрибация и получение текста из аудиофайла
         * @param {File} file Аудиофайл для транскрибации. Должен быть отправлен как бинарный файл (например, MP3, WAV).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentTranscribe: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postContentTranscribe', 'file', file)
            const localVarPath = `/content/transcribe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Роут принимает id юзера и возвращает его контент планы. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentGetContentPlans(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentGetContentPlans(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.getContentGetContentPlans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает `user_id` и `week_id` в query-параметрах и возвращает контент-планы пользователя для указанной недели. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {number} weekId ID недели
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentGetDetailContentPlan(weekId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentGetDetailContentPlan(weekId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.getContentGetDetailContentPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает id юзера и возвращает его посты. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentGetPostsNotInContentPlan(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentGetPostsNotInContentPlan(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.getContentGetPostsNotInContentPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает id, текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary обновление
         * @param {UpdatePostRequest} updatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchContentUpdatePost(updatePostRequest: UpdatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContentSavePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchContentUpdatePost(updatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.patchContentUpdatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает ответы на вопросы и историю постов. На основе этих данных генерируется контент план. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание контент плана
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentCreateContentPlan(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentTitles>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentCreateContentPlan(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentCreateContentPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает название поста и размер желаемого изображения. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание изображения на основе описания
         * @param {CreatePostImageRequest} createPostImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentCreateImagePost(createPostImageRequest: CreatePostImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContentCreateImagePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentCreateImagePost(createPostImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentCreateImagePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает описание изображения (prompt) и его размер. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание изображения на основе описания
         * @param {CreatePromptImageRequest} createPromptImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentCreateImagePrompt(createPromptImageRequest: CreatePromptImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContentCreateImagePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentCreateImagePrompt(createPromptImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentCreateImagePrompt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает ответы на вопросы, параметры длины, тему поста, дополнительные примечания и тип поста. На основе этих данных генерируется текст поста. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание поста на основе ответов
         * @param {CreatePostRequest} createPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentCreatePost(createPostRequest: CreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContentCreatePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentCreatePost(createPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает id поста и возвращает информацию о нем Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение информации о посте по id
         * @param {GetPostByIdRequest} getPostByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentGetPostById(getPostByIdRequest: GetPostByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavePostRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentGetPostById(getPostByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentGetPostById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает id поста и помечает его готовым  Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Пометить пост готовым к публикации
         * @param {MarkPostReadyToPublish} markPostReadyToPublish 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentMarkReadyToPublish(markPostReadyToPublish: MarkPostReadyToPublish, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentMarkReadyToPublish(markPostReadyToPublish, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentMarkReadyToPublish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Сохранение поста
         * @param {SavePostRequest} savePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentSavePost(savePostRequest: SavePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContentSavePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentSavePost(savePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentSavePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает аудиофайл и возвращает текст из него. Если данные невалидны, возвращается ошибка `400 Bad Request` 
         * @summary транскрибация и получение текста из аудиофайла
         * @param {File} file Аудиофайл для транскрибации. Должен быть отправлен как бинарный файл (например, MP3, WAV).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postContentTranscribe(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContentTranscribe200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postContentTranscribe(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.postContentTranscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Роут принимает id юзера и возвращает его контент планы. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGetContentPlans(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getContentGetContentPlans(options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает `user_id` и `week_id` в query-параметрах и возвращает контент-планы пользователя для указанной недели. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {number} weekId ID недели
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGetDetailContentPlan(weekId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getContentGetDetailContentPlan(weekId, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает id юзера и возвращает его посты. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение постов пользователя
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGetPostsNotInContentPlan(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getContentGetPostsNotInContentPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает id, текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary обновление
         * @param {UpdatePostRequest} updatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchContentUpdatePost(updatePostRequest: UpdatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostContentSavePost200Response> {
            return localVarFp.patchContentUpdatePost(updatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает ответы на вопросы и историю постов. На основе этих данных генерируется контент план. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание контент плана
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreateContentPlan(options?: RawAxiosRequestConfig): AxiosPromise<ContentTitles> {
            return localVarFp.postContentCreateContentPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает название поста и размер желаемого изображения. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание изображения на основе описания
         * @param {CreatePostImageRequest} createPostImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreateImagePost(createPostImageRequest: CreatePostImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostContentCreateImagePost200Response> {
            return localVarFp.postContentCreateImagePost(createPostImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает описание изображения (prompt) и его размер. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание изображения на основе описания
         * @param {CreatePromptImageRequest} createPromptImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreateImagePrompt(createPromptImageRequest: CreatePromptImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostContentCreateImagePost200Response> {
            return localVarFp.postContentCreateImagePrompt(createPromptImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает ответы на вопросы, параметры длины, тему поста, дополнительные примечания и тип поста. На основе этих данных генерируется текст поста. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Создание поста на основе ответов
         * @param {CreatePostRequest} createPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentCreatePost(createPostRequest: CreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostContentCreatePost200Response> {
            return localVarFp.postContentCreatePost(createPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает id поста и возвращает информацию о нем Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение информации о посте по id
         * @param {GetPostByIdRequest} getPostByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentGetPostById(getPostByIdRequest: GetPostByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<SavePostRequest> {
            return localVarFp.postContentGetPostById(getPostByIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает id поста и помечает его готовым  Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Пометить пост готовым к публикации
         * @param {MarkPostReadyToPublish} markPostReadyToPublish 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentMarkReadyToPublish(markPostReadyToPublish: MarkPostReadyToPublish, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postContentMarkReadyToPublish(markPostReadyToPublish, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Сохранение поста
         * @param {SavePostRequest} savePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentSavePost(savePostRequest: SavePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostContentSavePost200Response> {
            return localVarFp.postContentSavePost(savePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает аудиофайл и возвращает текст из него. Если данные невалидны, возвращается ошибка `400 Bad Request` 
         * @summary транскрибация и получение текста из аудиофайла
         * @param {File} file Аудиофайл для транскрибации. Должен быть отправлен как бинарный файл (например, MP3, WAV).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postContentTranscribe(file: File, options?: RawAxiosRequestConfig): AxiosPromise<PostContentTranscribe200Response> {
            return localVarFp.postContentTranscribe(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Роут принимает id юзера и возвращает его контент планы. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получение постов пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getContentGetContentPlans(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).getContentGetContentPlans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает `user_id` и `week_id` в query-параметрах и возвращает контент-планы пользователя для указанной недели. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получение постов пользователя
     * @param {number} weekId ID недели
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getContentGetDetailContentPlan(weekId: number, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).getContentGetDetailContentPlan(weekId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает id юзера и возвращает его посты. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получение постов пользователя
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public getContentGetPostsNotInContentPlan(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).getContentGetPostsNotInContentPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает id, текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary обновление
     * @param {UpdatePostRequest} updatePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public patchContentUpdatePost(updatePostRequest: UpdatePostRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).patchContentUpdatePost(updatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает ответы на вопросы и историю постов. На основе этих данных генерируется контент план. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Создание контент плана
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentCreateContentPlan(options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentCreateContentPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает название поста и размер желаемого изображения. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Создание изображения на основе описания
     * @param {CreatePostImageRequest} createPostImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentCreateImagePost(createPostImageRequest: CreatePostImageRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentCreateImagePost(createPostImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает описание изображения (prompt) и его размер. На основе этих данных генерируется изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Создание изображения на основе описания
     * @param {CreatePromptImageRequest} createPromptImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentCreateImagePrompt(createPromptImageRequest: CreatePromptImageRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentCreateImagePrompt(createPromptImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает ответы на вопросы, параметры длины, тему поста, дополнительные примечания и тип поста. На основе этих данных генерируется текст поста. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Создание поста на основе ответов
     * @param {CreatePostRequest} createPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentCreatePost(createPostRequest: CreatePostRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentCreatePost(createPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает id поста и возвращает информацию о нем Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получение информации о посте по id
     * @param {GetPostByIdRequest} getPostByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentGetPostById(getPostByIdRequest: GetPostByIdRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentGetPostById(getPostByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает id поста и помечает его готовым  Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Пометить пост готовым к публикации
     * @param {MarkPostReadyToPublish} markPostReadyToPublish 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentMarkReadyToPublish(markPostReadyToPublish: MarkPostReadyToPublish, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentMarkReadyToPublish(markPostReadyToPublish, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает текст поста и ссылку на изображение. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Сохранение поста
     * @param {SavePostRequest} savePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentSavePost(savePostRequest: SavePostRequest, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentSavePost(savePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает аудиофайл и возвращает текст из него. Если данные невалидны, возвращается ошибка `400 Bad Request` 
     * @summary транскрибация и получение текста из аудиофайла
     * @param {File} file Аудиофайл для транскрибации. Должен быть отправлен как бинарный файл (например, MP3, WAV).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public postContentTranscribe(file: File, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).postContentTranscribe(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomizeApi - axios parameter creator
 * @export
 */
export const CustomizeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает ответы пользователя на вопросы. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение ответов пользователя на вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomizeGetUserAnswers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customize/get_user_answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает ссылку на профиль и возвращает данные профиля. Если ссылка невалидна или профиль не найден, возвращается ошибка `400 Bad Request`. 
         * @summary Получить профиль по ссылке
         * @param {GetProfileFromUrlRequest} getProfileFromUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomizeGetProfileFromUrl: async (getProfileFromUrlRequest: GetProfileFromUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getProfileFromUrlRequest' is not null or undefined
            assertParamExists('postCustomizeGetProfileFromUrl', 'getProfileFromUrlRequest', getProfileFromUrlRequest)
            const localVarPath = `/customize/get_profile_from_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getProfileFromUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает в теле запроса данные для сохранения аккаунта, включая URL телеграм-канала, URL VK-канала и токен VK. Если данные невалидны или отсутствуют обязательные поля, возвращается ошибка `400 Bad Request`. 
         * @summary Сохранение данных аккаунта
         * @param {SaveAccountRequest} saveAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomizeSaveAccount: async (saveAccountRequest: SaveAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveAccountRequest' is not null or undefined
            assertParamExists('postCustomizeSaveAccount', 'saveAccountRequest', saveAccountRequest)
            const localVarPath = `/customize/save_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает ответы на вопросы и возвращает сгенерированный профиль. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получить профиль на основе ответов
         * @param {GetProfileFromAnswersRequest} getProfileFromAnswersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomizeSaveProfileAnswers: async (getProfileFromAnswersRequest: GetProfileFromAnswersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getProfileFromAnswersRequest' is not null or undefined
            assertParamExists('postCustomizeSaveProfileAnswers', 'getProfileFromAnswersRequest', getProfileFromAnswersRequest)
            const localVarPath = `/customize/save_profile_answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getProfileFromAnswersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomizeApi - functional programming interface
 * @export
 */
export const CustomizeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomizeApiAxiosParamCreator(configuration)
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает ответы пользователя на вопросы. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение ответов пользователя на вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomizeGetUserAnswers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProfileFromAnswersRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomizeGetUserAnswers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomizeApi.getCustomizeGetUserAnswers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает ссылку на профиль и возвращает данные профиля. Если ссылка невалидна или профиль не найден, возвращается ошибка `400 Bad Request`. 
         * @summary Получить профиль по ссылке
         * @param {GetProfileFromUrlRequest} getProfileFromUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomizeGetProfileFromUrl(getProfileFromUrlRequest: GetProfileFromUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomizeGetProfileFromUrl(getProfileFromUrlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomizeApi.postCustomizeGetProfileFromUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает в теле запроса данные для сохранения аккаунта, включая URL телеграм-канала, URL VK-канала и токен VK. Если данные невалидны или отсутствуют обязательные поля, возвращается ошибка `400 Bad Request`. 
         * @summary Сохранение данных аккаунта
         * @param {SaveAccountRequest} saveAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomizeSaveAccount(saveAccountRequest: SaveAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomizeSaveAccount(saveAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomizeApi.postCustomizeSaveAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает ответы на вопросы и возвращает сгенерированный профиль. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получить профиль на основе ответов
         * @param {GetProfileFromAnswersRequest} getProfileFromAnswersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomizeSaveProfileAnswers(getProfileFromAnswersRequest: GetProfileFromAnswersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCustomizeSaveProfileAnswers(getProfileFromAnswersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomizeApi.postCustomizeSaveProfileAnswers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomizeApi - factory interface
 * @export
 */
export const CustomizeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomizeApiFp(configuration)
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает ответы пользователя на вопросы. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение ответов пользователя на вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomizeGetUserAnswers(options?: RawAxiosRequestConfig): AxiosPromise<GetProfileFromAnswersRequest> {
            return localVarFp.getCustomizeGetUserAnswers(options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает ссылку на профиль и возвращает данные профиля. Если ссылка невалидна или профиль не найден, возвращается ошибка `400 Bad Request`. 
         * @summary Получить профиль по ссылке
         * @param {GetProfileFromUrlRequest} getProfileFromUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomizeGetProfileFromUrl(getProfileFromUrlRequest: GetProfileFromUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postCustomizeGetProfileFromUrl(getProfileFromUrlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает в теле запроса данные для сохранения аккаунта, включая URL телеграм-канала, URL VK-канала и токен VK. Если данные невалидны или отсутствуют обязательные поля, возвращается ошибка `400 Bad Request`. 
         * @summary Сохранение данных аккаунта
         * @param {SaveAccountRequest} saveAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomizeSaveAccount(saveAccountRequest: SaveAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postCustomizeSaveAccount(saveAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает ответы на вопросы и возвращает сгенерированный профиль. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получить профиль на основе ответов
         * @param {GetProfileFromAnswersRequest} getProfileFromAnswersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomizeSaveProfileAnswers(getProfileFromAnswersRequest: GetProfileFromAnswersRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postCustomizeSaveProfileAnswers(getProfileFromAnswersRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomizeApi - object-oriented interface
 * @export
 * @class CustomizeApi
 * @extends {BaseAPI}
 */
export class CustomizeApi extends BaseAPI {
    /**
     * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает ответы пользователя на вопросы. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получение ответов пользователя на вопросы
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomizeApi
     */
    public getCustomizeGetUserAnswers(options?: RawAxiosRequestConfig) {
        return CustomizeApiFp(this.configuration).getCustomizeGetUserAnswers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает ссылку на профиль и возвращает данные профиля. Если ссылка невалидна или профиль не найден, возвращается ошибка `400 Bad Request`. 
     * @summary Получить профиль по ссылке
     * @param {GetProfileFromUrlRequest} getProfileFromUrlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomizeApi
     */
    public postCustomizeGetProfileFromUrl(getProfileFromUrlRequest: GetProfileFromUrlRequest, options?: RawAxiosRequestConfig) {
        return CustomizeApiFp(this.configuration).postCustomizeGetProfileFromUrl(getProfileFromUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает в теле запроса данные для сохранения аккаунта, включая URL телеграм-канала, URL VK-канала и токен VK. Если данные невалидны или отсутствуют обязательные поля, возвращается ошибка `400 Bad Request`. 
     * @summary Сохранение данных аккаунта
     * @param {SaveAccountRequest} saveAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomizeApi
     */
    public postCustomizeSaveAccount(saveAccountRequest: SaveAccountRequest, options?: RawAxiosRequestConfig) {
        return CustomizeApiFp(this.configuration).postCustomizeSaveAccount(saveAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает ответы на вопросы и возвращает сгенерированный профиль. Если данные невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получить профиль на основе ответов
     * @param {GetProfileFromAnswersRequest} getProfileFromAnswersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomizeApi
     */
    public postCustomizeSaveProfileAnswers(getProfileFromAnswersRequest: GetProfileFromAnswersRequest, options?: RawAxiosRequestConfig) {
        return CustomizeApiFp(this.configuration).postCustomizeSaveProfileAnswers(getProfileFromAnswersRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handle payment webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Handle payment webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhook(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhook(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Handle payment webhook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWebhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Handle payment webhook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postWebhook(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postWebhook(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Роут принимает файл, загружает на s3 и возвращает ссылку. Если данные невалидны, возвращается ошибка `400 Bad Request` 
         * @summary Загружает файл на s3
         * @param {File} file Файл для загрузки на s3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFilesSaveImage: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('postFilesSaveImage', 'file', file)
            const localVarPath = `/files/save_image/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Роут принимает файл, загружает на s3 и возвращает ссылку. Если данные невалидны, возвращается ошибка `400 Bad Request` 
         * @summary Загружает файл на s3
         * @param {File} file Файл для загрузки на s3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFilesSaveImage(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFilesSaveImage(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FilesApi.postFilesSaveImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Роут принимает файл, загружает на s3 и возвращает ссылку. Если данные невалидны, возвращается ошибка `400 Bad Request` 
         * @summary Загружает файл на s3
         * @param {File} file Файл для загрузки на s3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFilesSaveImage(file: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postFilesSaveImage(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Роут принимает файл, загружает на s3 и возвращает ссылку. Если данные невалидны, возвращается ошибка `400 Bad Request` 
     * @summary Загружает файл на s3
     * @param {File} file Файл для загрузки на s3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public postFilesSaveImage(file: File, options?: RawAxiosRequestConfig) {
        return FilesApiFp(this.configuration).postFilesSaveImage(file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentCreatePayment: async (createPaymentRequest: CreatePaymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            assertParamExists('postPaymentCreatePayment', 'createPaymentRequest', createPaymentRequest)
            const localVarPath = `/payment/create-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Роут принимает промокод в теле запроса и access_token, refresh_token в заголовках. Если промокод валиден, он применяется к текущему заказу пользователя. Если промокод невалиден или токены недействительны, возвращается ошибка `400 Bad Request`. 
         * @summary Использование промокода
         * @param {UsePromoRequest} usePromoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentUsePromo: async (usePromoRequest: UsePromoRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usePromoRequest' is not null or undefined
            assertParamExists('postPaymentUsePromo', 'usePromoRequest', usePromoRequest)
            const localVarPath = `/payment/use_promo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usePromoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPaymentCreatePayment(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPaymentCreatePayment(createPaymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.postPaymentCreatePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Роут принимает промокод в теле запроса и access_token, refresh_token в заголовках. Если промокод валиден, он применяется к текущему заказу пользователя. Если промокод невалиден или токены недействительны, возвращается ошибка `400 Bad Request`. 
         * @summary Использование промокода
         * @param {UsePromoRequest} usePromoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPaymentUsePromo(usePromoRequest: UsePromoRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPaymentUsePromo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPaymentUsePromo(usePromoRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentApi.postPaymentUsePromo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentCreatePayment(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentResponse> {
            return localVarFp.postPaymentCreatePayment(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Роут принимает промокод в теле запроса и access_token, refresh_token в заголовках. Если промокод валиден, он применяется к текущему заказу пользователя. Если промокод невалиден или токены недействительны, возвращается ошибка `400 Bad Request`. 
         * @summary Использование промокода
         * @param {UsePromoRequest} usePromoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentUsePromo(usePromoRequest: UsePromoRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostPaymentUsePromo200Response> {
            return localVarFp.postPaymentUsePromo(usePromoRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @summary Create a payment
     * @param {CreatePaymentRequest} createPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public postPaymentCreatePayment(createPaymentRequest: CreatePaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).postPaymentCreatePayment(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Роут принимает промокод в теле запроса и access_token, refresh_token в заголовках. Если промокод валиден, он применяется к текущему заказу пользователя. Если промокод невалиден или токены недействительны, возвращается ошибка `400 Bad Request`. 
     * @summary Использование промокода
     * @param {UsePromoRequest} usePromoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public postPaymentUsePromo(usePromoRequest: UsePromoRequest, options?: RawAxiosRequestConfig) {
        return PaymentApiFp(this.configuration).postPaymentUsePromo(usePromoRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Роут принимает в теле запроса id поста и публикует его. Если ни один аккаунт не подключен, то возвращает ошибка. 
         * @summary Опубликовать пост в подключенные платформы
         * @param {GetPostByIdRequest} getPostByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPostsPublishPost: async (getPostByIdRequest: GetPostByIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getPostByIdRequest' is not null or undefined
            assertParamExists('postPostsPublishPost', 'getPostByIdRequest', getPostByIdRequest)
            const localVarPath = `/posts/publish_post`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getPostByIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration)
    return {
        /**
         * Роут принимает в теле запроса id поста и публикует его. Если ни один аккаунт не подключен, то возвращает ошибка. 
         * @summary Опубликовать пост в подключенные платформы
         * @param {GetPostByIdRequest} getPostByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPostsPublishPost(getPostByIdRequest: GetPostByIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPostsPublishPost(getPostByIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PostsApi.postPostsPublishPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PostsApiFp(configuration)
    return {
        /**
         * Роут принимает в теле запроса id поста и публикует его. Если ни один аккаунт не подключен, то возвращает ошибка. 
         * @summary Опубликовать пост в подключенные платформы
         * @param {GetPostByIdRequest} getPostByIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPostsPublishPost(getPostByIdRequest: GetPostByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postPostsPublishPost(getPostByIdRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
    /**
     * Роут принимает в теле запроса id поста и публикует его. Если ни один аккаунт не подключен, то возвращает ошибка. 
     * @summary Опубликовать пост в подключенные платформы
     * @param {GetPostByIdRequest} getPostByIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostsApi
     */
    public postPostsPublishPost(getPostByIdRequest: GetPostByIdRequest, options?: RawAxiosRequestConfig) {
        return PostsApiFp(this.configuration).postPostsPublishPost(getPostByIdRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfileApi - axios parameter creator
 * @export
 */
export const ProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает всю информацию о пользователе. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение ответов пользователя на вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileGetAllUserInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/profile/get_all_user_info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает всю информацию о пользователе. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение ответов пользователя на вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileGetAllUserInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileGetAllUserInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfileApi.getProfileGetAllUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfileApiFp(configuration)
    return {
        /**
         * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает всю информацию о пользователе. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
         * @summary Получение ответов пользователя на вопросы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileGetAllUserInfo(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getProfileGetAllUserInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     * Роут принимает access_token и refresh_token в заголовках, проверяет их и возвращает всю информацию о пользователе. Если токены невалидны, возвращается ошибка `400 Bad Request`. 
     * @summary Получение ответов пользователя на вопросы
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfileGetAllUserInfo(options?: RawAxiosRequestConfig) {
        return ProfileApiFp(this.configuration).getProfileGetAllUserInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



